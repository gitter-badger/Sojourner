#!/usr/bin/env python
# +----------------------------------------------------------------------+
# |                                                                      |
# |       _                      _   __  __                              |
# |      | |                    | | |  \/  |                             |
# |      | |_   _ _ __   ___  __| | | \  / | ___ _ __ ___   ___  _ __    |
# |  _   | | | | | '_ \ / _ \/ _` | | |\/| |/ _ \ '_ ` _ \ / _ \| '_ \   |
# | | |__| | |_| | | | |  __/ (_| | | |  | |  __/ | | | | | (_) | | | |  |
# |  \____/ \__,_|_| |_|\___|\__,_| |_|  |_|\___|_| |_| |_|\___/|_| |_|  |
# |                                                                      |
# | Author : Juned Memon            Email : junedm@tipsntraps.com        |
# +----------------------------------------------------------------------+


# +----------------------------------------------------------------------+
# | Version :                                             
# | Script  : 
# | Notes   : 
# |           
# |                                                                      
# +----------------------------------------------------------------------+
import re,argparse,commands,os,sys,sqlite3

from prettytable import PrettyTable #https://code.google.com/p/prettytable/wiki/Tutorial
from prettytable import from_db_cursor

try:
    import json
except ImportError:
    import simplejson as json
# +----------------------------------------------------------------------+
#Variables

SOUJOURNER_HOME='/home/junedm/Sojourner/'
dbname = SOUJOURNER_HOME+'inventory.db'
# +----------------------------------------------------------------------+
#http://code.activestate.com/recipes/578801-pretty-print-table-in-tabular-format/
# Pretty Print table in tabular format
def PrettyPrint(table, justify = "R", columnWidth = 0):
    # Not enforced but
    # if provided columnWidth must be greater than max column width in table!
    if columnWidth == 0:
        # find max column width
        for row in table:
            for col in row:
                width = len(str(col))
                if width > columnWidth:
                    columnWidth = width

    outputStr = ""
    for row in table:
        rowList = []
        for col in row:
            if justify == "R": # justify right
                rowList.append(str(col).rjust(columnWidth))
            elif justify == "L": # justify left
                rowList.append(str(col).ljust(columnWidth))
            elif justify == "C": # justify center
                rowList.append(str(col).center(columnWidth))
        outputStr += ' '.join(rowList) + "\n"
    return outputStr
# +----------------------------------------------------------------------+
# This is for ansible inventory
def grouplist(conn):

	inventory ={}
   	# Add group for [local] (e.g. local_action). If needed,
    	# set ansible_python_interpreter in host_vars/127.0.0.1
    	#inventory['local'] = [ '127.0.0.1' ]

	cur = conn.cursor()
    	cur.execute("SELECT Hostname,Role from ans_facts ORDER BY 1, 2")

	for row in cur.fetchall():
        	group = row['Role']
        	if group is None:
            		group = 'ungrouped'

        	# Add group with empty host list to inventory{} if necessary
        	if not group in inventory:
        		inventory[group] = {
                		'hosts' : []
            			}
        		inventory[group]['hosts'].append(row['Hostname'])

	cur.close()
	print json.dumps(inventory, indent=4)
	sys.exit(0)
# +----------------------------------------------------------------------+
def hostinfo(conn,name):

    vars = {}

    cur = conn.cursor()
    cur.execute("SELECT COUNT(*) FROM ans_facts WHERE Hostname=?", (name, ))

    row = cur.fetchone()
    if row[0] == 0:
        print json.dumps({})
        sys.exit(0)

    # Inject some variables for all hosts
    vars = {
        'admin'         : 'Juned Memon',
        'datacenter'    : 'colo'
    }

    # Assuming you *know* that certain hosts need special vars
    # and you can't or don't want to use host_vars/ group_vars,
    # you could specify them here. For example, I *know* that
    # hosts with the word 'ldap' in them need a base DN

    if 'ldap' in name.lower():
        vars['baseDN'] = 'dc=mens,dc=de'


    print json.dumps(vars, indent=4)

# +----------------------------------------------------------------------+
def show (args) :
        machine=args.machine
        role=args.role

	query='SELECT * FROM ans_facts'
	
	if machine:
		query1 = query + (" WHERE  Hostname=%s" %machine)
		#query1 = query + " where Hostname='" + machine + "'"

	elif role:
		query1 = query + " where Role like '%" + role + "%'"
	else :
		query1 = query
	data=execute_sql(query1)[0]
	print data
        return 0
# +----------------------------------------------------------------------+
def reap (args) :
        machine=args.machine
        query='DELETE FROM ans_facts'
        query1 = query + " where Hostname='" + machine + "'"
	data=execute_sql(query1)[1]
        if (data==1):
		print ("Successfully Removed %s from Inventory" %(machine))
        return 0
# +----------------------------------------------------------------------+
def execute_sql(sql) :
	#print sql
        #INVENTORY_HOME='/home/junedm/Sojourner/'
        #dbname = INVENTORY_HOME+'inventory.db'
        conn = sqlite3.connect(dbname)
        conn.row_factory=sqlite3.Row
        cur = conn.cursor()
        cur.execute(sql)
	affected_records=cur.rowcount
        pt = from_db_cursor(cur,print_empty=True)
	conn.commit()
        conn.close()
        return pt,affected_records
# +----------------------------------------------------------------------+
def assign(args):
	machine=args.machine
	product=args.product
	role=args.role
	
	# Creat a Temp inventory file for this server
	content="[all]\n"
	tab="\t"
	content=content+machine+ "\tProduct=" + product + "\tRole=" + role + "\n"
	file="/tmp/"+machine+".yml"
	fo = open(file, "wb")
	fo.write(content);
	fo.close()
	## What will be path for play 
	path=SOUJOURNER_HOME+"/plays/"+ product + "/" + role +".yml"
	if not os.path.exists(path):
        	# this means the Playbook does not exist for this Product/Role
            	raise Exception("Sorry.. It seems the Playbook for the Product does not exist.Make sure its available at %s." %path)
	     	return 1

	cmd="ansible-playbook -i "+ file + " " + path
	status,output = commands.getstatusoutput(cmd)
	if status == 0:
		#Cool playbook run successfull"
		print ("Successfully Deployed  %s/%s on %s " %(product,role,machine))
		
		
	else :
		#Maa ki tang, kuch gadbad ho gayi
		print "Error"
		print output

	#os.remove(file)
	return 0
# +----------------------------------------------------------------------+
def menu ():

        parser = argparse.ArgumentParser(description="Sojourner")

        subparsers = parser.add_subparsers()

        parser_show = subparsers.add_parser('show',help="show's all the host")
        parser_show.add_argument("-m", "--machine", help="host name to search for")
        parser_show.add_argument("-r", "--role", help="Role of the machine to search for.This will be regex.")
        parser_show.set_defaults(func=show)

        parser_reap  = subparsers.add_parser('reap', help="Delete the host from Inventory")
        parser_reap.add_argument("-m", "--machine", help="host name to reap",required=True)
        parser_reap.set_defaults(func=reap)

        parser_reap  = subparsers.add_parser('assign', help="Assigns the host and runs the playbook for the assigned project")
        parser_reap.add_argument("-m", "--machine", help="host name to reap",required=True)
        parser_reap.add_argument("-p", "--product", help="Product",required=True)
        parser_reap.add_argument("-r", "--role", help="Role",required=True)
        parser_reap.set_defaults(func=assign)

        args = parser.parse_args()

        args.func(args)
        return 0
# +----------------------------------------------------------------------+
def main():

	conn = sqlite3.connect(dbname)
	conn.row_factory=sqlite3.Row

	if len(sys.argv) == 2 and (sys.argv[1] == '--list'):
        	grouplist(conn)
	elif len(sys.argv) == 3 and (sys.argv[1] == '--host'):
        	hostinfo(conn,sys.argv[2])
	else :
        	menu()

	conn.close()
# +----------------------------------------------------------------------+
# +----------------------------------------------------------------------+
if __name__ == "__main__":
         sys.exit(main())
